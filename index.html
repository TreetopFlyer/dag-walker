<div id="app"></div>
<script type="module">

import { h, Component, render } from 'https://unpkg.com/preact?module';

var N = {
    ID:{
        Walk:0,
        Instance:0
    },
    Create:(inMeta, ...inChildren) =>
    {
        var output = {
            Meta:inMeta,
            Link:{
                Hierarchy: {Get:[], Set:[]},
                ModifyUp:  {Get:[], Set:[]},
                ModifyDown:{Get:[], Set:[]},
                ModifyOut: {Get:[], Set:[]},
            },
            ID:{
                Walk:0,
                Instance:N.ID.Instance++
            }
        };
        inChildren.forEach( inChild => N.Connect(output, inChild, "Hierarchy") );
        return output;
    },
    Flow:(inNode, inType, inForward) => (inForward === undefined || inForward === true) ? inNode.Link[inType].Set : inNode.Link[inType].Get,
    Connect:(inNodeMajor, inNodeMinor, inKey) =>
    {
        inNodeMajor.Link[inKey].Set.push(inNodeMinor);
        inNodeMinor.Link[inKey].Get.push(inNodeMajor);
    },
    Disconnect:(inNodeMajor, inNodeMinor, inKey) =>
    {
        let checkRemove = (inArray, inMember) => inArray.findIndex( (inMember, inIndex, inArray) => (inMember === match) ? inArray.splice(inIndex, 1) : false );
        
        // if no minor node was passed, cut all of the major node's "Set" connections under inKey (removes all "children")
        if(inNodeMinor == null){
            let array = inNodeMajor[inKey].Set
            array.forEach( nodeMinor =>
            {
                checkRemove(nodeMinor.Link[inKey].Get, nodeMinor);
            });
            array = [];
            return;
        }

        // if no major node was passed, cut all of the minor node's "Get" connections under inKey (removes all "parents")
        if(inNodeMajor == null){
            let array = inNodeMinor[inKey].Get
            array.forEach( nodeMajor =>
            {
                checkRemove(nodeMajor.Link[inKey].Set, nodeMajor);
            });
            array = [];
            return;
        }

        checkRemove(inNodeMajor.Link[inKey].Set, inNodeMinor);
        checkRemove(inNodeMinor.Link[inKey].Get, inNodeMajor);
    },
    Walk:(inIterator, inNode, inKey, inForwards) =>
    {
        let array = N.Flow(inNode, inKey, inForwards);
        for(let i=0; i<array.length; i++)
        {
            let next = array[i];
            if(next.ID.Walk !== N.ID.Walk)
            {
                next.ID.Walk = N.ID.Walk;
                let results = inIterator(next);
                if(results !== false)
                {
                    N.Walk(inIterator, next, inKey, inForwards);
                }
            }
        }
    },
    Modify(inNode)
    {
        N.ID.Walk++;

        let leaves = [];
        let gatherUp = n => N.Connect(inNode, n, "ModifyUp");
        let gatherDown = n =>
        {
            N.Connect(inNode, n, "ModifyDown");
            N.Flow(n, "Hierarchy").length == 0 ?  leaves.push(n) : null;
        };
        let gatherOut = n => N.Connect(inNode, n, "ModifyOut");

        N.Walk(gatherUp, inNode, "Hierarchy", false);
        N.Connect(inNode, inNode, "ModifyDown");
        N.Walk(gatherDown, inNode, "Hierarchy");
        leaves.forEach(leaf=>N.Walk(gatherOut, leaf, "Hierarchy", false));
    }
};


let tree1 = N.Create("root1",
    N.Create("branch1", 
        N.Create("leaf1"),
        N.Create("leaf2"),
        N.Create("leaf3"),
    ),
    N.Create("branch2",
        N.Create("leaft3"),
        N.Create("leaft4")
    )
);

let leaves = [];
let leavesCollect = n =>
{
    if(n.Children.length == 0)
    {
        leaves.push(n);
    }
};
N.Walk(leavesCollect, tree1, "Hierarchy");

let tree2 = N.Create("root2", 
    N.Create("branch3",
        N.Create("leaf5"),
        N.Create("leaf6")
    ),
    N.Create("branch4", ...leaves)
);

let orchard = N.Create("orchard", tree1, tree2);


N.Modify(tree1);


let Leafify = inRows => inRows.map(r => N.Create({Row:r}));
let Pivot = (inParent, inColumnIndicies, inSumIndicies, inDepth) =>
{
    
    //arguments:
    //    - a Node with leaf Nodes temporarily stored in its Meta.Leaves
    //        - where each leaf Node has a row of table data in it's Meta.Row
    //    - a list of columns to pivot on
    //    - a list of columns to sum
    //    - optional traversal depth, defaults to 0
    let depth = inDepth||0;
    let uniques = {};
    inParent.Meta.Leaves.forEach((inLeaf)=>
    {
        let row = inLeaf.Meta.Row; // shorthand for the raw "CSV" row in the leaf Node's Meta
        let value = row[inColumnIndicies[depth]]; // get the pivot column
        let match = uniques[value]; // check in the uniques list if this pivot column exists
        if(!match)
        {
            // if not, store a value under that key that will be the meta object for a new child
            match = uniques[value] = {
                Label:value,
                Row:inSumIndicies.map((inColumnIndex, inIndex, inArray) => row[inColumnIndex]), // create a Meta.Row also on the new child nodes to store summed totals
                Leaves:[]
            };
            // grow a child off of the parent using the meta object
            N.Connect(inParent, N.Create(match), "Hierarchy");
        }
        else
        {
            // if a match does exist, sum the appropriate columns
            inSumIndicies.forEach((inColumnIndex, inIndex, inArray) => match.Row[inIndex] += row[inColumnIndex]);
        }
        // move the leaves into the child
        match.Leaves.push(inLeaf);
    });
    
    delete inParent.Meta.Leaves;
    var children = N.Flow(inParent, "Hierarchy");
    if(depth >= inColumnIndicies.length-1)
    {
        children.forEach( inChild =>
        {
            inChild.Meta.Leaves.forEach( inLeaf => N.Connect(inChild, inLeaf, "Hierarchy") );
            delete inChild.Meta.Leaves;
        });
    }
    else
    {
        children.forEach( child => Pivot(child, inColumnIndicies, inSumIndicies, depth+1) );
    }

};
let csv = Leafify([
    ["#1", "a", "long",  1],
    ["#2", "b", "long",  2],
    ["#3", "b", "short", 2],
    ["#4", "a", "long",  3],
    ["#5", "b", "short", 1],
    ["#6", "a", "short", 0],
    ["#7", "b", "short", 7],
]);
let pivotRoot1 = N.Create({Leaves:csv});
Pivot(pivotRoot1, [1, 2], [3]);
let pivotRoot2 = N.Create({Leaves:csv});
Pivot(pivotRoot2, [2, 1], [3]);

let pivots = [pivotRoot1, pivotRoot2];

let ElNode = ({node}) =>
{
    var nodeChildren = N.Flow(node, "Hierarchy");
    var children = [];
    var table = [];

    if(node.Meta.Row)
    {
        table = node.Meta.Row.map( cell => h("span", {style:{padding:"10px"}}, cell));
    }
    children =  [
        h("strong", null, node.Meta.Label||"a node"),
        ...table
    ];

    if(nodeChildren.length)
    {
        children = [
            ...children,
            ...nodeChildren.map( inChild => h(ElNode, {node:inChild}))
        ];
    }
    return h("div", {style:{padding:"10px"}}, children);
}

let ElPivot = ({pivot}) =>
{
    return h("div", {style:{display:"inline-block"}}, [
        h(ElNode, {node:pivot})
    ]);
}
let ElRoot = ({pivots}) =>
{
    return h("div", null, [
        h("h3", null, "tree view"),
        ...pivots.map(pivot=>h(ElPivot, {pivot}))
    ])
};
render(h(ElRoot, {pivots}, null), document.querySelector("#app"));

</script>
